#!/usr/bin/python2

import Queue
from pyroute2 import IPDB
from pyroute2 import IPRoute 
import signal
import threading
import time 

work_queue = Queue.Queue()
ip = IPDB()

class Worker(threading.Thread):
    def run(self):
        while True:
            msg = work_queue.get()
	    if msg['event'] == 'RTM_NEWLINK':
		plugin(msg)


#when you plug in an the ethernet adapter we get the ip of the interface
def plugin(msg):
    interface =  msg['attrs'][0][1]
    state     =  msg['attrs'][2][1]           
    print interface + ":" + state   
   
    if state == "UP":
        while not get_ip(interface): 
            time.sleep(1)
        ip_msg = get_ip(interface)
        ip_addr = ip_msg[0]['attrs'][1][1]
        ip_broadcast = ip_msg[0]['attrs'][2][1]
        print ip_addr  


# POSIX signal handler to ensure we shutdown cleanly

def get_ip(interface):
    ipr = IPRoute()
    return ipr.get_addr(label=interface) 
    

def handler(signum, frame):
    print "\nShutting down IPDB instance..."
    ip.release()

# Called by the IPDB Netlink listener thread for _every_ message (route, neigh, etc,...)
def callback(ipdb, msg, action):
        work_queue.put(msg)

def main():
    # Register our handler for keyboard interrupt and termination signals
    signal.signal(signal.SIGINT, handler)
    signal.signal(signal.SIGTERM, handler)
    
    # Worker thread
    worker = Worker()
    worker.daemon = True
    worker.start()
    
    # Register our callback to the IPDB
    ip.register_callback(callback)

    # The process main thread does nothing but waiting for signals
    signal.pause()

main()
